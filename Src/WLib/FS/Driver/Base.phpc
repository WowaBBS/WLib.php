<?
  $Loader->Parent_Class('/Object');
  $Loader->Load_Type('/FS/Driver/Node');
  $Loader->Load_Type('/Inet/Url');
  $Loader->Load_Type('/FS/Attr/Mode');
  $Loader->Load_Type('/FS/Attr/Hash');
  $Loader->Load_Type('/FS/Attr/IntId');
  $Loader->Load_Type('/FS/Attr/Date/UnixTime' );
  $Loader->Load_Type('/FS/Driver/Attr' );

  Use T_FS_Attr_Date_UnixTime As FileTime ;
  Use T_FS_Attr_Mode          As Mode     ;
  Use T_FS_Attr_Hash          As Hash     ;
  Use T_FS_Attr_IntId         As IntId    ;
  Use T_FS_Driver_Attr        As Attr     ;

  Class C_FS_Driver_Base Extends C_Object
    Implements ArrayAccess
  {
    Var $Attr;
  
    Function _Init($Args)
    {
      $this->Attr=$this->Create_Object('/FS/Attr/Manager');
      Parent::_Init($Args);
      $this->Attr_Init($this->Attr);
    }
    
    Function Load($Path, $Args=[])
    {
      $Offset =$Args['Offset' ]?? 0     ;
      $Length =$Args['Length' ]?? Null  ;
      $Lock   =$Args['Lock'   ]?? True  ;
      $Text   =$Args['Text'   ]?? False ;
        
      $Flags=omReadOnly
        |($Lock? omShareable:0)
        |($Text? omText:omBinary)
      ;
        
      $f=$this->Stream($Path, $Flags);
      If(!$f)
        Return False;
      If($Offset) $f->Seek($Offset);
      $Res=$Length===Null? $f->ReadAll():$f->Read($Length);
      $f->Close();
      Return $Res;
    }
 
    Function Save($Path, $Data, $Args=[])
    {
      $Append =$Args['Append' ]?? False;
      $Lock   =$Args['Lock'   ]?? False;
      $Text   =$Args['Text'   ]?? False;
        
      $Flags=omWriteOnly|omCreate
        |($Append? omAppEnd:omClear)
        |($Lock? omExclusive:0)
        |($Text? omText:omBinary)
      ;
        
      $f=$this->Stream($Flags);
      If(!$f)
        Return False;
      $f->Write($Data);
      $f->Close();
    }
 
    Function Include($Include_Path, $UnPack_Vars=[], $Pack_Vars=[]) { $this->Call($Path, 'Include', ['UnPack_Vars'=>$UnPack_Vars, 'Pack_Vars'=>$Pack_Vars]); }
  //Function Include($Include_Path, $UnPack_Vars=[], $Pack_Vars=[]) { Return $this->Content_Include($this->Load($Include_Path), ['UnPack_Vars'=>$UnPack_Vars, 'Pack_Vars'=>$Pack_Vars]); }
  //Function Include($Include_Path, $UnPack_Vars=[], $Pack_Vars=[]) { Return $this->Real_Include($this->SysPath($Include_Path), ['UnPack_Vars'=>$UnPack_Vars, 'Pack_Vars'=>$Pack_Vars]); }
 
    Function _Content_Include($Content, $Args=[])
    {
      $UnPack_Vars =$Args['UnPack_Vars' ]?? [];
      $Pack_Vars   =$Args['Pack_Vars'   ]?? [];
      Extract($UnPack_Vars);
      $Res=Eval('?>'.$Content); //.'<?'
      ForEach($Pack_Vars As $Pack_Var)
        $UnPack_Vars[$Pack_Var]=${$Pack_Var};
      Return $Res;
    }
 
    Function _Real_Include($SysPath, $Args=[])
    {
      $UnPack_Vars =$Args['UnPack_Vars' ]?? [];
      $Pack_Vars   =$Args['Pack_Vars'   ]?? [];
      Extract($UnPack_Vars);
      $Res=Include $SysPath;
      ForEach($Pack_Vars As $Pack_Var)
        $UnPack_Vars[$Pack_Var]=${$Pack_Var};
      Return $Res;
    }
 
    Function URL($Path) { Return New T_Inet_Url(); }
    Function Vars($Path) { Return []; }
 
    Function Node($Path=False)
    {
      Return New T_FS_Driver_Node($this, $Path);
    }
    
    Static Function MaskToRegex($Mask)
    {
      If(!$Mask) Return '';
    
      $Mask=Str_Replace('.', '\.', $Mask);
      $Mask=Str_Replace('*', '.*', $Mask);
      $Mask=Str_Replace('?', '.?', $Mask);
      Return '/^'.$Mask.'$/iSs';
    }
    
  //****************************************************************
  // Cache
  
    Function _ClearCache($Path, $Args)
    {
      $Res=[];
      Return $Res;
    }
    
  //****************************************************************
    Function Attr_Init($Attr)
    {
      Attr::Init_System  ($Attr);
      Attr::Init_Path    ($Attr);
      Attr::Init_Stat    ($Attr);
      Attr::Init_Test    ($Attr);
      $this->Attr_Init_Content ($Attr);

      $Attr->Register([
        'Remove' =>fn($Node, $Args)=>$Node->_Remove($Args),
        'ClearCache' =>fn($Driver, $Path, $Args)=>$Driver->_ClearCache($Path, $Args),
      ]);
    }
    
    Function Attr_Init_Content($Attr)
    {
      $Attr->Register([
      //'Content'    =>[fn($Driver, $Path, $Args)=>$Driver->_Load($Path, $Args), fn($Driver, $Content, $SysPath, $Args)=>$Driver->_Save($Path, $Content, $Args) ,'Cache'=>True],

        'Md5'  => fn($Content)=>Hash::FromBinary($Content, 'Md5'  ),
        'Sha1' => fn($Content)=>Hash::FromBinary($Content, 'Sha1' ),
      ]);
    }
    
    Function GetSet(String $Path ,Array $Key ,$Args=[], $Vars=[]) { Return $this->Attr->GetSet($Key ,$Args, $Vars+['Driver'=>$this, 'Path'=>$Path, 'Args'=>[]]); }
    
  //****************************************************************
  // ArrayAccess interface

    Public Function OffsetExists ($k    ):Bool  { return True;     }
    Public Function OffsetGet    ($k    ):Mixed { return $this->Node($k); }
    Public Function OffsetSet    ($k ,$v):Void  { $this->Log('Fatal', 'Unsupported'); }
    Public Function OffsetUnset  ($k    ):Void  { $this->Log('Fatal', 'Unsupported'); }
    
  //****************************************************************
  }
?>