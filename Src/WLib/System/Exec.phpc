<?
  $Loader->Parent_Class('/Object');

  $Loader->Load_Lib('/FS/Utils');

  Class C_System_Exec extends C_Object
  {
    Var $Env           =Null;
    Var $Command       ='';
    Var $WorkDirectory =Null;
    Var $Handle        ;
    Var $InPipes       =Array();
    Var $OutPipes      =Array();
    Var $Pipes         =Array();
  
    Var $_TempFile=False;
  
    Function Enveroments_Default_Get()
    {
      $p=$this->Create_Object('/System/Exec');
      $p->Command=$this->Win_Command('SET');
      $p->Open();
      $i=&$p->Stream_Output();
      $res=$i->Contents_Get();
      $i->Close();
      $i->Done();
      $p->Close();
      $p->Done();
      $res=Explode("\r\n", $res);
      $Res=Array();
      ForEach($res As $v)
        If(StrLen($v))
        {
          $v=Explode('=', $v, 2);
          $Res[$v[0]]=$v[1];
        }
      Return $Res;
    }
  
    Function Win_Command($Cmd)
    {
      If(IsSet($_SERVER['COMSPEC']))
        $CS=$_SERVER['COMSPEC'];
      ElseIf(IsSet($_SERVER['ComSpec']))
        $CS=$_SERVER['ComSpec'];
      Else
        $CS='cmd';
      Return $CS.' /C '.$Cmd;
    }
    
    Function AddPath($Path)
    {
      $Env=&$this->Env;
      if(!$Env)
        $Env=[];
      static $_Path='Path'; //? Case ignore
      if(!IsSet($Env[$_Path]))
        $Env[$_Path]='';
      $Env[$_Path]=$Path.';'.$Env[$_Path];
    }
  
    Function Open()
    {
      $this->Close();
      $Pipes=[];
      if(false)
        $this->Debug([
          $this->Command,
          $this->InPipes,
          $Pipes,
          $this->WorkDirectory,
          $this->Env
        ]);
      if(Is_Array($this->Env['argv']??false))
        UnSet($this->Env['argv']);
    //$this->Log('Log', 'Exec_Open ', $this->Command);
      $Command=$this->Command;
      if(PHP_OS_FAMILY==='Windows' && Is_String($Command))
        $Command='"'.$Command.'"';
      $this->Handle=Proc_Open(
        $Command,
        $this->InPipes,
        $Pipes,
        $this->WorkDirectory,
        $this->Env
      );
      if($this->Handle==False)
        $this->Log('Error', 'Can`t create process: ', $this->Command);
      ForEach($Pipes As $k=>$v)
        $this->OutPipes[$k]=$this->Create_Object('/Stream/Handle', ['Handle'=>$v]);
    }
  
    Function GetStream($i) { return $this->OutPipes[$i]??false; }
    Function Stream_Input  () { return $this->GetStream(0); }
    Function Stream_Output () { return $this->GetStream(1); }
    Function Stream_Error  () { return $this->GetStream(2); }

    Function SetStream($i, $v, $Op=null)
    {
      $Op??=$i>0;
      if(Is_Bool  ($Op)) $Op=$Op? 'w':'r';
      if($v===true     ) return $this->InPipes[$i]=['pipe',              $Op]; // Default
      if(Is_Null   ($v)) return $this->InPipes[$i]=['file', FS_Dev_Null, $Op];
      if(Is_String ($v)) return $this->InPipes[$i]=['file', $v         , $Op];
      #0 => ['pipe', 'r'], // stdin is a pipe that the child will read from
      #1 => ['pipe'. 'w'], // stdout is a pipe that the child will write to
      #2 => ['pipe', 'w'], // stderr is a file to write to
      $this->Log('Fatal', 'TODO: Implement');
    }
    
    Function SetStream_Input  ($v=true) { return $this->SetStream(0, $v); }
    Function SetStream_Output ($v=true) { return $this->SetStream(1, $v); }
    Function SetStream_Error  ($v=true) { return $this->SetStream(2, $v); }
  
    Function Is_Alive() { Return $this->GetStatus()['running']; }
    Function GetExitCode() { Return $this->GetStatus()['exitcode']; }
    
    Function GetStatus()
    {
      if($this->Handle)
        return Proc_Get_Status($this->Handle);
      $this->Debug($this->Handle);
      $this->Log('Fatal', 'Called get status not from process');
      return [
        'command'  =>  ''  ,
        'pid'      =>   0  ,
        'running'  =>False ,
        'signaled' =>False ,
        'stopped'  =>True  ,
        'exitcode' =>   0  ,
        'termsig'  =>   0  ,
        'stopsig'  =>   0  ,
      ];
    }
  
    Function Execute($Sync=true)
    {
      If(!$this->Handle)
        $this->Open();
      ElseIf(!$this->Is_Alive())
      {
        $this->Close();
        $this->Open();
      }
      else
      {
        $this->Wait();
        $this->Close();
        $this->Open();
      }
      if($Sync)
      {
        $this->Wait();
        $this->Close();
        return true;
      }
      return $this->Is_Alive(); // TODO:
    }
    
    Function Wait()
    {
      while($this->Is_Alive())
      {
        usleep(100000);
      //echo '.';
      }
    }
    
    Function Terminate() //TODO: Second param
    {
      Proc_Terminate($this->Handle);
    }
  
    Function Close()
    {
      If(!$this->Handle)
        Return;
      { // Debug, todo remove
        $S=$this->GetStatus();
        UnSet($S['command' ]);
        UnSet($S['pid'     ]);
        if($S['running'  ]===false ) UnSet($S['running'  ]);
        if($S['signaled' ]===false ) UnSet($S['signaled' ]);
        if($S['stopped'  ]===false ) UnSet($S['stopped'  ]);
        UnSet($S['exitcode' ]); //if($S['exitcode' ]===0     ) 
        if($S['termsig'  ]===0     ) UnSet($S['termsig'  ]);
        if($S['stopsig'  ]===0     ) UnSet($S['stopsig'  ]);
        if($S)
        {
          $Log=$this->Log('Error', 'Exec::Close ', $this->Command);
          ForEach($S As $k=>$v)
            $Log('    ', $k, '="', $v, '"');
        }
      }
      $Pipes=$this->Pipes;
      $this->Pipes=Array();
      If(IsSet($Pipes[0])) $Pipes[0]->Close();
      If(IsSet($Pipes[1])) $Pipes[1]->Close();
      If(IsSet($Pipes[2])) $Pipes[2]->Close();
      Proc_Close($this->Handle);
      $this->Handle=False;
    }
  
    Function _Done()
    {
      $this->Close();
      parent::_Done();
    }
  }
 
?>