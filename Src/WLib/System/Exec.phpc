<?
  $Loader->Parent_Class('/Object');

  $Loader->Load_Lib('/FS/Utils');

  Class C_System_Exec extends C_Object
  {
    Var $Env           =Null;
    Var $Command       ='';
    Var $WorkDirectory =Null;
    Var $Handle        ;
    Var $InPipes       =[];
    Var $OutPipes      =[];
  
    Var $_TempFile=False;

    Protected Function _Init(Array $Args)
    {
      $this->Env           =$Args['Env'           ]?? $this->Env           ;
      $this->Command       =$Args['Command'       ]?? $this->Command       ;
      $this->WorkDirectory =$Args['WorkDirectory' ]?? $this->WorkDirectory ;
      if(Array_Key_Exists('Input'  ,$Args)) $this->SetStream_Input  ($Args['Input'  ]);
      if(Array_Key_Exists('Output' ,$Args)) $this->SetStream_Output ($Args['Output' ]);
      if(Array_Key_Exists('Error'  ,$Args)) $this->SetStream_Error  ($Args['Error'  ]);
      ForEach($Args['Pipes' ]?? [] As $k=>$v)
        $this->SetStream($k, $v);
      Parent::_Init($Args);
    }
  
    Function Enveroments_Default_Get()
    {
      $p=$this->Create_Object('/System/Exec');
      $p->Command=$this->Win_Command('SET');
      $p->Open();
      $i=&$p->Stream_Output();
      $res=$i->Contents_Get();
      $i->Close();
      $i->Done();
      $p->Close();
      $p->Done();
      $res=Explode("\r\n", $res);
      $Res=[];
      ForEach($res As $v)
        If(StrLen($v))
        {
          $v=Explode('=', $v, 2);
          $Res[$v[0]]=$v[1];
        }
      Return $Res;
    }
  
    Function Win_Command($Cmd)
    {
      If(IsSet($_SERVER['COMSPEC']))
        $CS=$_SERVER['COMSPEC'];
      ElseIf(IsSet($_SERVER['ComSpec']))
        $CS=$_SERVER['ComSpec'];
      Else
        $CS='cmd';
      Return $CS.' /C '.$Cmd;
    }
    
    Function AddPath($Path)
    {
      $Env=&$this->Env;
      if(!$Env)
        $Env=[];
      static $_Path='Path'; //? Case ignore
      if(!IsSet($Env[$_Path]))
        $Env[$_Path]='';
      $Env[$_Path]=$Path.';'.$Env[$_Path];
    }
  
    Function Open()
    {
      $this->Close();
      $Pipes=[];
      if(false)
        $this->Debug([
          $this->Command,
          $this->InPipes,
          $Pipes,
          $this->WorkDirectory,
          $this->Env
        ]);
      if(Is_Array($this->Env['argv']??false))
        UnSet($this->Env['argv']);
    //$this->Log('Log', 'Exec_Open ', $this->Command);
      $Command=$this->Command;
      if(PHP_OS_FAMILY==='Windows' && PHP_MAJOR_VERSION<8 && Is_String($Command))
        $Command='"'.$Command.'"';
      $this->Handle=Proc_Open(
        $Command,
        $this->InPipes,
        $Pipes,
        $this->WorkDirectory,
        $this->Env
      );
      if($this->Handle==False)
        $this->Log('Error', 'Can`t create process: ', $this->Command);
      ForEach($Pipes As $k=>$v)
        $this->OutPipes[$k]=$this->Create_Object('/Stream/Handle', ['Handle'=>$v]);
    }
    
    Function GetStreamIdx($i)
    {
      if(Is_String($i))
      {
        static $Types=[
          'Input'  =>0, 'input'  =>0, 'StdIn'  =>0, 'stdin'  =>0,
          'Output' =>1, 'output' =>1, 'StdOut' =>1, 'stdout' =>1,
          'Error'  =>2, 'error'  =>2, 'StdErr' =>2, 'stderr' =>2,
        ];
        $i=$Types[$i]?? $Types[StrToLower($i)]?? null;
      }
      if(!Is_Integer($i))
        return $this->Log('Error', 'Invalid stream index')->Ret();
      return $i;
    }
  
    Function GetStream($i) { return $this->OutPipes[$this->GetStreamIdx($i)]??false; }
    Function Stream_Input  () { return $this->GetStream(0); }
    Function Stream_Output () { return $this->GetStream(1); }
    Function Stream_Error  () { return $this->GetStream(2); }

    Function _SetStream($i, $v)
    {
      $this->InPipes[$i]=$v;
    }

    Function SetStream($i, $v, $Op=null)
    {
      $i=$this->GetStreamIdx($i);
      $Op??=$i>0;
      if(Is_Bool    ($Op)) $Op=$Op? 'w':'r';
      if($v===true       ) return $this->_SetStream($i, ['pipe',              $Op]); // Default
      if(Is_Null     ($v)) return $this->_SetStream($i, ['file', FS_Dev_Null, $Op]);
      if(Is_String   ($v)) return $this->_SetStream($i, ['file', $v         , $Op]);
      if(Is_Array    ($v)) return $this->_SetStream($i,          $v               );
      if(Is_Resource ($v)) return $this->_SetStream($i,          $v               );
      #0 => ['pipe', 'r'], // stdin is a pipe that the child will read from
      #1 => ['pipe'. 'w'], // stdout is a pipe that the child will write to
      #2 => ['pipe', 'w'], // stderr is a file to write to
      $this->Log('Fatal', 'TODO: Implement');
    }
    
    Function SetStream_Input  ($v=true) { return $this->SetStream(0, $v); }
    Function SetStream_Output ($v=true) { return $this->SetStream(1, $v); }
    Function SetStream_Error  ($v=true) { return $this->SetStream(2, $v); }
  
    Function Is_Alive() { Return $this->GetStatus()['running']; }
    Function GetExitCode() { Return $this->GetStatus()['exitcode']; }
    
    Protected $ExitCode=-1;
    
    Function GetStatus()
    {
      $Res=$this->_GetStatus();
      if($Res['exitcode']===-1)
        $Res['exitcode']=$this->ExitCode;
      else
        $this->ExitCode=$Res['exitcode'];
      return $Res;
    }
    
    Protected Function _GetStatus()
    {
      if($this->Handle)
        return Proc_Get_Status($this->Handle);
      $this->Debug($this->Handle);
      $this->Log('Fatal', 'There is no handle for getting status');
      return [
        'command'  =>  ''  ,
        'pid'      =>   0  ,
        'running'  =>False ,
        'signaled' =>False ,
        'stopped'  =>True  ,
        'exitcode' =>  -1  ,
        'termsig'  =>   0  ,
        'stopsig'  =>   0  ,
      ];
    }
  
    Function Execute($Sync=true)
    {
      If(!$this->Handle)
        $this->Open();
      ElseIf(!$this->Is_Alive())
      {
        $this->Close();
        $this->Open();
      }
      else
      {
        $this->Wait();
        $this->Close();
        $this->Open();
      }
      if($Sync)
      {
        $this->Wait();
        $this->Close();
        return true;
      }
      return $this->Is_Alive(); // TODO:
    }
    
    Function WaitIdle()
    {
      USleep(100000);
    }
    
    Function Wait($CallBack=null)
    {
      while($this->Is_Alive())
      {
        if($CallBack && $CallBack()===True)
          Continue;
        $this->WaitIdle();
      }
    }
    
    Function Terminate() //TODO: Second param
    {
      Proc_Terminate($this->Handle);
    }
  
    Function Close()
    {
      If(!$this->Handle)
        Return;
      { // Debug, todo remove
        $S=$this->GetStatus();
        UnSet($S['command' ]);
        UnSet($S['pid'     ]);
        if($S['running'  ]===false ) UnSet($S['running'  ]);
        if($S['signaled' ]===false ) UnSet($S['signaled' ]);
        if($S['stopped'  ]===false ) UnSet($S['stopped'  ]);
        UnSet($S['exitcode' ]); //if($S['exitcode' ]===0     ) 
        if($S['termsig'  ]===0     ) UnSet($S['termsig'  ]);
        if($S['stopsig'  ]===0     ) UnSet($S['stopsig'  ]);
        if($S)
        {
          $Log=$this->Log('Error', 'Exec::Close ', $this->Command);
          ForEach($S As $k=>$v)
            $Log('    ', $k, '="', $v, '"');
          $Log->Done();
        }
      }
      $Pipes=$this->OutPipes;
      $this->OutPipes=Array();
      If(IsSet($Pipes[0])) $Pipes[0]->Close();
      If(IsSet($Pipes[1])) $Pipes[1]->Close();
      If(IsSet($Pipes[2])) $Pipes[2]->Close();
      Proc_Close($this->Handle);
      $this->Handle=False;
    }
  
    Function _Done()
    {
      $this->Close();
      parent::_Done();
    }
  }
 
?>